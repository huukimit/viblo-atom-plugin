// Generated by CoffeeScript 1.12.3
(function() {
  var BufferedProcess,
  VibloAPI,
  CompositeDisposable,
  Emitter,
  PostManager,
  _,
  createJsonParseError,
  createProcessError,
  handleProcessErrors,
  ref,
  semver,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore-plus');

  ref = require('atom'), BufferedProcess = ref.BufferedProcess, CompositeDisposable = ref.CompositeDisposable, Emitter = ref.Emitter;

  semver = require('semver');

  VibloAPI = require('./viblo-api');

  module.exports = PostManager = (function() {
    PostManager.prototype.CACHE_EXPIRY = 1000 * 60 * 10;

    function PostManager() {
      this.postPromises = [];
      this.emitter = new Emitter;
    }

    PostManager.prototype.getClient = function() {
      return this.apiClient != null ? this.apiClient : this.apiClient = new VibloAPI(this);
    };


    PostManager.prototype.getPublished = function(callback) {
      return this.getClient().request('/posts/published', function(data) {
        console.log(data);
      })
    }

    PostManager.prototype.loadPackage = function(packageName, callback) {
      var apmProcess, args, errorMessage;
      args = ['view', packageName, '--json'];
      errorMessage = "Fetching package '" + packageName + "' failed.";
      apmProcess = this.runCommand(args, function(code, stdout, stderr) {
        var error, packages, parseError, ref1;
        if (code === 0) {
          try {
            packages = (ref1 = JSON.parse(stdout)) != null ? ref1 : [];
          } catch (error1) {
            parseError = error1;
            error = createJsonParseError(errorMessage, parseError, stdout);
            return callback(error);
          }
          return callback(null, packages);
        } else {
          error = new Error(errorMessage);
          error.stdout = stdout;
          error.stderr = stderr;
          return callback(error);
        }
      });
      return handleProcessErrors(apmProcess, errorMessage, callback);
    };

    PostManager.prototype.search = function(query, options) {

    };

    PostManager.prototype.update = function(pack, newVersion, callback) {
    };

    PostManager.prototype.install = function(pack, callback) {
    };

    // удаление поста
    PostManager.prototype.delete = function(post, callback) {

    };

    // проверка ревизии поста
    PostManager.prototype.canUpgrade = function(installedPackage, availableVersion) {
      var installedVersion;
      if (installedPackage == null) {
        return false;
      }
      installedVersion = installedPackage.metadata.version;
      if (!semver.valid(installedVersion)) {
        return false;
      }
      if (!semver.valid(availableVersion)) {
        return false;
      }
      return semver.gt(availableVersion, installedVersion);
    };

    // !
    PostManager.prototype.getPackageTitle = function(arg) {
      var name;
      name = arg.name;
      return _.undasherize(_.uncamelcase(name));
    };

    // !
    PostManager.prototype.getRepositoryUrl = function(arg) {
    };


    PostManager.prototype.emitPostEvent = function(eventName, post, error) {
      var ref1, ref2, theme;
      theme = (ref1 = pack.theme) != null ? ref1 : (ref2 = pack.metadata) != null ? ref2.theme : void 0;
      eventName = theme ? "theme-" + eventName : "package-" + eventName;
      return this.emitter.emit(eventName, {
        pack: pack,
        error: error
      });
    };
    PostManager.prototype.on = function(selectors, callback) {
      var i, len, ref1, selector, subscriptions;
      subscriptions = new CompositeDisposable;
      ref1 = selectors.split(" ");
      for (i = 0, len = ref1.length; i < len; i++) {
        selector = ref1[i];
        subscriptions.add(this.emitter.on(selector, callback));
      }
      return subscriptions;
    };

    return PostManager;

  })();

  createJsonParseError = function(message, parseError, stdout) {
    var error;
    error = new Error(message);
    error.stdout = '';
    error.stderr = parseError.message + ": " + stdout;
    return error;
  };

  createProcessError = function(message, processError) {
    var error;
    error = new Error(message);
    error.stdout = '';
    error.stderr = processError.message;
    return error;
  };

  handleProcessErrors = function(apmProcess, message, callback) {
    return apmProcess.onWillThrowError(function(arg) {
      var error, handle;
      error = arg.error, handle = arg.handle;
      handle();
      return callback(createProcessError(message, error));
    });
  };

}).call(this);
